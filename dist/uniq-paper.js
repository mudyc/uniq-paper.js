// Generated by CoffeeScript 1.9.1
var B, Colors, G, PMill, R, RGBtoYST, TexGenXYRepeatUnit, W, Wb, Wg, Wr, YSTtoRGB, clampSat, det, gamma, inUnit, linear_to_monitor, matvecmul, maxYSTsat, offset;

det = function(mat) {
  return +mat[0][0] * (mat[1][1] * mat[2][2] - mat[1][2] * mat[2][1]) - mat[0][1] * (mat[1][0] * mat[2][2] - mat[1][2] * mat[2][0]) + mat[0][2] * (mat[1][0] * mat[2][1] - mat[1][1] * mat[2][0]);
};

matvecmul = function(mat, v) {
  return [mat[0][0] * v[0] + mat[0][1] * v[1] + mat[0][2] * v[2], mat[1][0] * v[0] + mat[1][1] * v[1] + mat[1][2] * v[2], mat[2][0] * v[0] + mat[2][1] * v[1] + mat[2][2] * v[2]];
};

R = [.64, .33];

G = [.30, .60];

B = [.15, .06];

W = [.3127268660, .3290235126];

gamma = 2.4;

offset = .055;

R = [R[0], R[1], 1 - R[0] - R[1]];

G = [G[0], G[1], 1 - G[0] - G[1]];

B = [B[0], B[1], 1 - B[0] - B[1]];

W = [W[0], W[1], 1 - W[0] - W[1]];

Wr = (R[1] * det([W, G, B])) / (W[1] * det([R, G, B]));

Wg = (G[1] * det([R, W, B])) / (W[1] * det([R, G, B]));

Wb = (B[1] * det([R, G, W])) / (W[1] * det([R, G, B]));

inUnit = function(vec) {
  return jQuery.map(vec, function(x) {
    if ((0 < x && x < 1)) {
      return void 0;
    } else {
      return 1;
    }
  }).length === 0;
};

linear_to_monitor = function(rgb) {
  var f;
  f = function(x) {
    var c, t, t2;
    if (x < 0) {
      return -f(-x);
    }
    if (offset === 0) {
      return Math.pow(x, 1.0 / gamma);
    }
    t = offset / (gamma - 1);
    t2 = Math.pow(t * gamma / (1 + offset), gamma);
    c = t / Math.pow(t * gamma / (1 + offset), gamma);
    if (x < t2) {
      return x * c;
    }
    return Math.pow(x, 1.0 / gamma) * (1 + offset) - offset;
  };
  return [f(rgb[0]), f(rgb[1]), f(rgb[2])];
};

clampSat = function(rgb) {
  var S, T, Y, r, ref;
  if (inUnit(rgb)) {
    return rgb;
  }
  ref = RGBtoYST(rgb), Y = ref[0], S = ref[1], T = ref[2];
  r = maxYSTsat([Y, S, T]);
  return YSTtoRGB([Y, r * S, r * T]);
};

YSTtoRGB = function(v) {
  var mat;
  mat = [[1, Wg + Wb, (Wb - Wg) / Math.sqrt(3)], [1, -Wr, (2 * Wb + Wr) / Math.sqrt(3)], [1, -Wr, -(2 * Wg + Wr) / Math.sqrt(3)]];
  return matvecmul(mat, v);
};

RGBtoYST = function(v) {
  var mat;
  mat = [[Wr, Wg, Wb], [1, -.5, -.5], [0, .5 * Math.sqrt(3), -.5 * Math.sqrt(3)]];
  return matvecmul(mat, v);
};

maxYSTsat = function(YST) {
  var Y, vec;
  Y = YSTtoRGB([YST[0], 0, 0]);
  vec = YSTtoRGB([0, YST[1], YST[2]]);
  return Math.min(((vec[0] > 0) - Y[0]) / vec[0], ((vec[1] > 0) - Y[1]) / vec[1], ((vec[2] > 0) - Y[2]) / vec[2]);
};

window.LtoY = function(L) {
  if (L <= 8) {
    return L * (27.0 / 24389);
  } else {
    return Math.pow((L + 16.0) / 116, 3.0);
  }
};

window.nextGaussian = function() {
  var multiplier, s, v1, v2;
  while (true) {
    v1 = 2 * Math.random() - 1;
    v2 = 2 * Math.random() - 1;
    s = v1 * v1 + v2 * v2;
    if (!(s >= 1 || s === 0)) {
      break;
    }
  }
  multiplier = Math.sqrt(-2 * Math.log(s) / s);
  return v1 * multiplier;
};

window.shuffle = function(a) {
  var i, j, t;
  i = a.length;
  while (--i > 0) {
    j = ~~(Math.random() * (i + 1));
    t = a[j];
    a[j] = a[i];
    a[i] = t;
  }
  return a;
};

Colors = (function() {
  function Colors(gl, seed) {
    var blend, c, cc, col, colors, getangle, hue0, huerange, hues, i, lumrange, lums, minlum, sats, x, yst;
    colors = 8;
    minlum = 80;
    blend = 0;
    Math.seedrandom(seed);
    huerange = nextGaussian() * 90;
    getangle = function(f) {
      var angles, fract, index, n;
      angles = [0, 30, 60, 120, 180, 240, 300, 360];
      n = angles.length - 1;
      f *= n / 360.0;
      index = Math.round(f) % n;
      fract = f - Math.round(f);
      return (1 - fract) * angles[index] + fract * angles[index + 1];
    };
    hue0 = Math.random() * 360;
    hues = [hue0, hue0 + huerange];
    hues = hues.concat((function() {
      var k, ref, results;
      results = [];
      for (i = k = 2, ref = colors; 2 <= ref ? k < ref : k > ref; i = 2 <= ref ? ++k : --k) {
        results.push(hue0 + Math.random() * huerange);
      }
      return results;
    })());
    hues = jQuery.map(hues, getangle);
    shuffle(hues);
    lumrange = 100 - minlum;
    if (colors === 1) {
      x = Math.random();
      x = 1 - Math.sqrt(1 - x);
      lums = [minlum + x * lumrange];
    } else {
      lums = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 0, ref = (colors + 1) / 2; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
          results.push(minlum + Math.random() * lumrange / 2);
        }
        return results;
      })();
      lums = lums.concat((function() {
        var k, ref, ref1, results;
        results = [];
        for (i = k = ref = (colors + 1) / 2, ref1 = colors; ref <= ref1 ? k < ref1 : k > ref1; i = ref <= ref1 ? ++k : --k) {
          results.push(minlum + (1 + Math.random()) * lumrange / 2);
        }
        return results;
      })());
    }
    sats = (function() {
      var k, ref, results;
      results = [];
      for (i = k = 0, ref = colors; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        results.push(1 - (1 - Math.pow(1 - Math.random(), 2)) * (Math.random() < .333));
      }
      return results;
    })();
    yst = (function() {
      var k, ref, results;
      results = [];
      for (i = k = 0, ref = colors; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        results.push([LtoY(lums[i]), sats[i] * Math.cos(hues[i] * Math.PI / 180), sats[i] * Math.sin(hues[i] * Math.PI / 180)]);
      }
      return results;
    })();
    col = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = yst.length; k < len; k++) {
        c = yst[k];
        results.push(linear_to_monitor(clampSat(YSTtoRGB(c))));
      }
      return results;
    })();
    shuffle(col);
    if (blend > 0) {
      col = (function() {
        var k, len, results;
        results = [];
        for (k = 0, len = col.length; k < len; k++) {
          cc = col[k];
          results.push((function() {
            var l, len1, results1;
            results1 = [];
            for (l = 0, len1 = cc.length; l < len1; l++) {
              c = cc[l];
              results1.push(blend * 1 + (1 - blend) * c);
            }
            return results1;
          })());
        }
        return results;
      })();
    }
    this.colors = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = col.length; k < len; k++) {
        c = col[k];
        results.push(c.join(' '));
      }
      return results;
    })();
    this.colorarrs = col;
    this.randvecs = (function() {
      var k, results;
      results = [];
      for (i = k = 0; k < 15; i = ++k) {
        results.push([Math.random(), Math.random(), Math.random()]);
      }
      return results;
    })();
    console.log(hues, lums, sats, yst, col, this);
  }

  Colors.prototype.get_color = function(idx) {
    return this.colorarrs[idx];
  };

  Colors.prototype.get_rand = function(idx) {
    return this.randvecs[idx];
  };

  return Colors;

})();

TexGenXYRepeatUnit = (function() {
  function TexGenXYRepeatUnit() {
    var angle, angle_stddev, as, at, lendiff_mean, lendiff_stddev, m, m0, rs, rt, scale, scale_log_stddev, vecs;
    vecs = null;
    scale = .3;
    scale_log_stddev = 0.4;
    angle_stddev = .065;
    lendiff_mean = 0;
    lendiff_stddev = .1;
    if (vecs !== null) {
      this.vecs = vecs;
      return;
    }
    angle = (.25 + angle_stddev * nextGaussian()) * 2 * Math.PI;
    angle *= 1 - 2 * (Math.random() < 0.5);
    as = Math.random() * 2 * Math.PI;
    at = as + angle;
    m0 = scale_log_stddev * nextGaussian();
    m = lendiff_mean + lendiff_stddev * nextGaussian();
    rs = scale * Math.exp(m0 + m);
    rt = scale * Math.exp(m0 - m);
    this.vecs = [[rs * Math.cos(as), rt * Math.cos(at)], [rs * Math.sin(as), rt * Math.sin(at)]];
  }

  return TexGenXYRepeatUnit;

})();

PMill = (function() {
  var numpasses;

  numpasses = 3;

  function PMill() {}

  PMill.prototype.getPaper = function(seed) {
    var blend, colors, foo, minlum, numcolors, passes, rootrep, scale, seeds, vecs;
    numcolors = 8;
    minlum = 80;
    blend = 0;
    vecs = void 0;
    colors = new Colors(gl, Math.random());
    rootrep = TexGenXYRepeatUnit(rng, scale = 60 * scaleFactor, vecs = vecs);
    passes = [
      {
        "trans": 0,
        "emboss": 0
      }, {
        "trans": .5,
        "emboss": 0
      }, {
        "trans": .9375,
        "emboss": 0
      }
    ][{
      0: numpasses
    }];
    return seeds = (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = passes.length; k < len; k++) {
        foo = passes[k];
        results.push(Math.random() * 2000000000);
      }
      return results;
    })();
  };

  return PMill;

})();
// Generated by CoffeeScript 1.9.1
var NamedTextures;

NamedTextures = (function() {
  var textures;

  textures = {};

  NamedTextures.prototype.get_random_tex = function() {
    var names;
    names = this.get_names();
    return textures[names[Math.floor(Math.random() * names.length)]];
  };

  NamedTextures.prototype.get_names = function() {
    return ["rgbw1", "rgbw2", "rgbw3", "turb", "pyramid", "cone", "saw", "triangle", "rnd0", "rnd1", "rnd2", "stripe", "rnd0n", "rnd1n", "rnd2n"];
  };

  function NamedTextures(gl) {
    var fn, j, len, ref, self, t;
    gl.getExtension('OES_texture_float');
    gl.getExtension('OES_float_linear');
    gl.getExtension('OES_half_float_linear');
    self = this;
    ref = this.get_names();
    fn = function(t) {
      var i, k, len1, process, results;
      process = function(data) {
        var arr, buff, height, ncomp, tex_type, texture, width;
        width = data.width;
        height = data.height;
        tex_type = data.type;
        ncomp = data.ncomp;
        buff = data.data;
        data.magfilter = data.minfilter = 'NEAREST';
        arr = new Float32Array(buff);
        texture = gl.createTexture();
        textures[t] = texture;
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.FLOAT, arr);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, data.magfilter === 'NEAREST' ? gl.NEAREST : gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, data.minfilter === 'NEAREST' ? gl.NEAREST : gl.LINEAR_MIPMAP_LINEAR);
        if (data.minfilter !== 'NEAREST') {
          gl.generateMipmap(gl.TEXTURE_2D);
        }
        gl.bindTexture(gl.TEXTURE_2D, null);
        if (self.get_names().length === Object.keys(textures).length) {
          return $(self).trigger('ready');
        }
      };
      if (TEX_DATA !== void 0) {
        results = [];
        for (k = 0, len1 = TEX_DATA.length; k < len1; k++) {
          i = TEX_DATA[k];
          if (i.name === t) {
            results.push(process(i));
          } else {
            results.push(void 0);
          }
        }
        return results;
      } else {
        return $.getJSON('/texture/' + t, function(data) {
          return process(data);
        });
      }
    };
    for (j = 0, len = ref.length; j < len; j++) {
      t = ref[j];
      fn(t);
    }
    this;
  }

  NamedTextures.prototype.get_tex = function(name) {
    return textures[name];
  };

  return NamedTextures;

})();
// Generated by CoffeeScript 1.9.1
var Shader;

Shader = (function() {
  function Shader(gl) {
    this.programs = [];
    this.programs.push(this._make_program(gl, "attribute vec2 a_position;\n" + "attribute vec2 a_texCoord0;\n" + "attribute vec2 a_texCoord1;\n" + "uniform vec2 u_resolution;\n" + "varying vec2 tc0;\n" + "varying vec2 tc1;\n" + "void main() {\n" + "  // convert the rectangle from pixels to 0.0 to 1.0\n" + "  vec2 zeroToOne = a_position / u_resolution;\n" + "  // convert from 0->1 to 0->2\n" + "  vec2 zeroToTwo = zeroToOne * 2.0;\n" + "  // convert from 0->2 to -1->+1 (clipspace)\n" + "  vec2 clipSpace = zeroToTwo - 1.0;\n" + "  gl_Position = vec4(clipSpace, 0, 1);\n" + "  tc0 = a_texCoord0;\n" + "  tc1 = a_texCoord1;\n" + "}\n", "precision highp float;\n" + "uniform sampler2D tex0;\n" + "uniform sampler2D tex1;\n" + "uniform vec3 color0;\n" + "uniform vec3 color1;\n" + "uniform vec3 color2;\n" + "uniform vec3 r0;\n" + "uniform vec3 r1;\n" + "varying vec2 tc0;\n" + "varying vec2 tc1;\n" + "void main(){\n" + "    vec3 t0 = vec3(texture2D(tex0, tc0));\n" + "    vec3 t1 = vec3(texture2D(tex1, tc1));\n" + "    float spare0 = dot(t0, t1);\n" + "    float spare1 = spare0 * spare0;\n" + "    float ef = spare1 * dot(t0, r0);\n" + "    gl_FragColor = vec4(mix(color0, color1, ef).rgb,1);\n" + "}\n"));
    this.programs.push(this._make_program(gl, "attribute vec2 a_position;\n" + "attribute vec2 a_texCoord0;\n" + "attribute vec2 a_texCoord1;\n" + "uniform vec2 u_resolution;\n" + "varying vec2 tc0;\n" + "varying vec2 tc1;\n" + "void main() {\n" + "  // convert the rectangle from pixels to 0.0 to 1.0\n" + "  vec2 zeroToOne = a_position / u_resolution;\n" + "  // convert from 0->1 to 0->2\n" + "  vec2 zeroToTwo = zeroToOne * 2.0;\n" + "  // convert from 0->2 to -1->+1 (clipspace)\n" + "  vec2 clipSpace = zeroToTwo - 1.0;\n" + "  gl_Position = vec4(clipSpace, 0, 1);\n" + "  tc0 = a_texCoord0;\n" + "  tc1 = a_texCoord1;\n" + "}\n", "precision highp float;\n" + "varying vec2 tc0;\n" + "varying vec2 tc1;\n" + "uniform sampler2D tex0;\n" + "uniform sampler2D tex1;\n" + "uniform vec3 color0;\n" + "uniform vec3 color1;\n" + "uniform vec3 color2;\n" + "uniform vec3 r0;\n" + "uniform vec3 r1;\n" + "void main(){\n" + "    vec3 t0 = vec3(texture2D(tex0, tc0));\n" + "    vec3 t1 = vec3(texture2D(tex1, tc1));\n" + "    float spare0 = dot(t0, r0);\n" + "    float spare1 = dot(t1, r1);\n" + "    vec3 tmp = mix(color0, color1, spare0);\n" + "    vec4 color = vec4(mix(tmp, color2, spare1).rgb, 1);\n" + "    color.a = abs(spare0*spare0 - spare1*spare1);\n" + "    gl_FragColor = color;\n" + "}\n"));
    this.programs.push(this._make_program(gl, "attribute vec2 a_position;\n" + "attribute vec2 a_texCoord0;\n" + "attribute vec2 a_texCoord1;\n" + "uniform vec2 u_resolution;\n" + "varying vec2 tc0;\n" + "varying vec2 tc1;\n" + "void main() {\n" + "  // convert the rectangle from pixels to 0.0 to 1.0\n" + "  vec2 zeroToOne = a_position / u_resolution;\n" + "  // convert from 0->1 to 0->2\n" + "  vec2 zeroToTwo = zeroToOne * 2.0;\n" + "  // convert from 0->2 to -1->+1 (clipspace)\n" + "  vec2 clipSpace = zeroToTwo - 1.0;\n" + "  gl_Position = vec4(clipSpace, 0, 1);\n" + "  tc0 = a_texCoord0;\n" + "  tc1 = a_texCoord1;\n" + "}\n", "precision highp float;\n" + "varying vec2 tc0;\n" + "varying vec2 tc1;\n" + "uniform sampler2D tex0;\n" + "uniform sampler2D tex1;\n" + "uniform vec3 color0;\n" + "uniform vec3 color1;\n" + "uniform vec3 color2;\n" + "uniform vec3 r0;\n" + "uniform vec3 r1;\n" + "void main(){\n" + "    vec3 t0 = vec3(texture2D(tex0, tc0));\n" + "    vec3 t1 = vec3(texture2D(tex1, tc1));\n" + "    float spare0 = dot(t0, t1);\n" + "    float spare1 = -spare0;\n" + "    vec3 tmp = mix(color0, color1, spare1);\n" + "    vec4 color = vec4(mix(tmp, color2, spare1).rgb, 1);\n" + "    color.a = t0.b * r0.b + t1.b * r1.b;\n" + "    gl_FragColor = color;\n" + "}\n"));
  }

  Shader.prototype.setup = function(gl, ind, obj) {
    var attr, buffer, color0, color1, color2, program, r0, r1, resolutionLocation, tex0, tex1, texCoordBuffer, texCoordBuffer2, texCoordLocation;
    program = this.programs[ind];
    gl.useProgram(program);
    resolutionLocation = gl.getUniformLocation(program, "u_resolution");
    gl.uniform2f(resolutionLocation, obj.u_resolution.width, obj.u_resolution.height);
    texCoordLocation = gl.getAttribLocation(program, "a_texCoord0");
    texCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(texCoordLocation);
    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
    texCoordLocation = gl.getAttribLocation(program, "a_texCoord1");
    texCoordBuffer2 = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer2);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(texCoordLocation);
    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
    tex0 = gl.getUniformLocation(program, "tex0");
    tex1 = gl.getUniformLocation(program, "tex1");
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, obj.tex0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, obj.tex1);
    gl.uniform1i(tex0, 0);
    gl.uniform1i(tex1, 1);
    color0 = gl.getUniformLocation(program, "color0");
    gl.uniform3f(color0, obj.c0[0], obj.c0[1], obj.c0[2]);
    color1 = gl.getUniformLocation(program, "color1");
    gl.uniform3f(color1, obj.c1[0], obj.c1[1], obj.c1[2]);
    color2 = gl.getUniformLocation(program, "color2");
    gl.uniform3f(color2, obj.c2[0], obj.c2[1], obj.c2[2]);
    r0 = gl.getUniformLocation(program, "r0");
    gl.uniform3f(r0, obj.r0[0], obj.r0[1], obj.r0[2]);
    r1 = gl.getUniformLocation(program, "r1");
    gl.uniform3f(r1, obj.r1[0], obj.r1[1], obj.r1[2]);
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    attr = gl.getAttribLocation(program, "a_position");
    gl.enableVertexAttribArray(attr);
    return gl.vertexAttribPointer(attr, 2, gl.FLOAT, false, 0, 0);
  };

  Shader.prototype._make_program = function(gl, vertex, shader) {
    var lastError, linked, program;
    program = gl.createProgram();
    program.vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(program.vs, vertex);
    program.fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(program.fs, shader);
    gl.compileShader(program.vs);
    if (!gl.getShaderParameter(program.vs, gl.COMPILE_STATUS)) {
      alert(gl.getShaderInfoLog(program.vs));
      console.trace();
      return null;
    }
    gl.compileShader(program.fs);
    if (!gl.getShaderParameter(program.fs, gl.COMPILE_STATUS)) {
      alert(gl.getShaderInfoLog(program.fs));
      console.trace();
      return null;
    }
    gl.attachShader(program, program.vs);
    gl.attachShader(program, program.fs);
    gl.deleteShader(program.vs);
    gl.deleteShader(program.fs);
    gl.linkProgram(program);
    linked = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!linked) {
      lastError = gl.getProgramInfoLog(program);
      console.log(lastError);
      return null;
    }
    return program;
  };

  return Shader;

})();
