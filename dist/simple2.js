// Generated by CoffeeScript 1.9.1
var createProgramFromScripts, createShaderFromScriptElement, errFn, error, getShader, loadProgram, main, makeTexture, run_programs, setRectangle;

error = console.log;

errFn = error;

loadProgram = function(gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {
  var i, ii, j, lastError, len, len1, linked, program;
  errFn = console.log;
  program = gl.createProgram();
  for (i = 0, len = shaders.length; i < len; i++) {
    ii = shaders[i];
    gl.attachShader(program, ii);
  }
  if (opt_attribs) {
    for (j = 0, len1 = opt_attribs.length; j < len1; j++) {
      ii = opt_attribs[j];
      gl.bindAttribLocation(program, opt_locations ? opt_locations[ii] : ii, opt_attribs[ii]);
    }
  }
  gl.linkProgram(program);
  linked = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!linked) {
    lastError = gl.getProgramInfoLog(program);
    console.log(lastError);
    gl.deleteProgram(program);
    return null;
  }
  return program;
};

window.createProgram = loadProgram;

createProgramFromScripts = function(gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {
  var i, ii, len, shaders;
  shaders = [];
  for (i = 0, len = shaderScriptIds.length; i < len; i++) {
    ii = shaderScriptIds[i];
    shaders.push(createShaderFromScript(gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], opt_errorCallback));
  }
  return loadProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);
};

getShader = function(gl, id) {
  var k, shader, shaderScript, str;
  shaderScript = document.getElementById(id);
  if (!shaderScript) {
    return null;
  }
  str = "";
  k = shaderScript.firstChild;
  while (k) {
    if (k.nodeType === 3) {
      str += k.textContent;
    }
    k = k.nextSibling;
  }
  shader = null;
  if (shaderScript.type === "x-shader/x-fragment") {
    shader = gl.createShader(gl.FRAGMENT_SHADER);
  } else if (shaderScript.type === "x-shader/x-vertex") {
    shader = gl.createShader(gl.VERTEX_SHADER);
  } else {
    return null;
  }
  console.log(str);
  gl.shaderSource(shader, str);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    alert(gl.getShaderInfoLog(shader));
    return null;
  }
  console.log('sh');
  return shader;
};

createShaderFromScriptElement = getShader;

makeTexture = function(imageData) {
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, imageData.width, imageData.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData.data);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, generateMipmaps > 1 ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
  if (generateMipmaps) {
    return gl.generateMipmap(gl.TEXTURE_2D);
  }
};

setRectangle = function(gl, x, y, width, height) {
  var x1, x2, y1, y2;
  x1 = x;
  x2 = x + width;
  y1 = y;
  y2 = y + height;
  return gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
};

run_programs = function(gl) {
  var lastError, linked, program;
  program = gl.createProgram();
  program.vs = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(program.vs, "attribute vec2 a_position;\n" + "attribute vec2 a_texCoord;\n" + "uniform vec2 u_resolution;\n" + "varying vec2 tc;\n" + "void main() {\n" + "  // convert the rectangle from pixels to 0.0 to 1.0\n" + "  vec2 zeroToOne = a_position / u_resolution;\n" + "  // convert from 0->1 to 0->2\n" + "  vec2 zeroToTwo = zeroToOne * 2.0;\n" + "  // convert from 0->2 to -1->+1 (clipspace)\n" + "  vec2 clipSpace = zeroToTwo - 1.0;\n" + "  gl_Position = vec4(clipSpace, 0, 1);\n" + "  tc = a_texCoord;\n" + "}\n");
  program.fs = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(program.fs, "precision highp float;\n" + "uniform sampler2D tex;\n" + "varying vec2 tc;\n" + "void main(){\n" + "    vec4 tmp = texture2D(tex, tc);\n" + "    tmp.a = 1.0;\n" + "    gl_FragColor = tmp;\n" + "}\n");
  gl.compileShader(program.vs);
  if (!gl.getShaderParameter(program.vs, gl.COMPILE_STATUS)) {
    alert(gl.getShaderInfoLog(program.vs));
    return null;
  }
  gl.compileShader(program.fs);
  if (!gl.getShaderParameter(program.fs, gl.COMPILE_STATUS)) {
    alert(gl.getShaderInfoLog(program.fs));
    return null;
  }
  gl.attachShader(program, program.vs);
  gl.attachShader(program, program.fs);
  gl.deleteShader(program.vs);
  gl.deleteShader(program.fs);
  gl.linkProgram(program);
  linked = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!linked) {
    lastError = gl.getProgramInfoLog(program);
    console.log(lastError);
    return null;
  }
  gl.useProgram(program);
  return program;
};

main = function() {
  var attr, buffer, canvas, colors, gl, h, i, idx, len, nt, program, ref, resolutionLocation, sh, t, texCoordBuffer, texCoordLocation, w, x, y;
  console.log("ASDFADSF");
  canvas = document.getElementById("canvas");
  gl = canvas.getContext("experimental-webgl");
  window.gl = gl;
  console.log(canvas, gl);
  nt = new NamedTextures(gl);
  console.log('got ready');
  program = run_programs(gl);
  resolutionLocation = gl.getUniformLocation(program, "u_resolution");
  gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
  texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
  texCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(texCoordLocation);
  gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
  buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  attr = gl.getAttribLocation(program, "a_position");
  gl.enableVertexAttribArray(attr);
  gl.vertexAttribPointer(attr, 2, gl.FLOAT, false, 0, 0);
  x = y = 0;
  w = h = 150;
  idx = 0;
  ref = nt.get_names();
  for (i = 0, len = ref.length; i < len; i++) {
    t = ref[i];
    gl.bindTexture(gl.TEXTURE_2D, nt.get_tex(t));
    setRectangle(gl, x, y, w, h);
    x += w;
    idx += 1;
    if (idx % 4 === 0) {
      y += h;
      x = 0;
    }
    gl.drawArrays(gl.TRIANGLES, 0, 6);
  }
  colors = new Colors(gl, Math.random());
  sh = new Shader(gl);
  sh.setup(gl, 0, {
    tex0: nt.get_random_tex(),
    tex1: nt.get_random_tex(),
    u_resolution: {
      width: canvas.width,
      height: canvas.height
    },
    c0: colors.get_color(0),
    c1: colors.get_color(1),
    c2: colors.get_color(2),
    r0: colors.get_rand(0),
    r1: colors.get_rand(1)
  });
  setRectangle(gl, 50, 50, 300, 300);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
  gl.disable(gl.DEPTH_TEST);
  return gl.drawArrays(gl.TRIANGLES, 0, 6);
};

window.onload = main;
